\documentclass[12pt]{article}

\usepackage[a4paper,margin=2.5cm,footskip=0.7cm,headheight=1cm]{geometry}

\usepackage{mathtools}
\usepackage{amsmath}
\usepackage{scalerel,amssymb}
\usepackage{gensymb}
\usepackage{graphicx}
\usepackage{caption}
\usepackage{german}
\usepackage{tikz}

\newcommand{\overtext}[2]{\mathrel{\overset{\makebox[0pt]{\mbox{\normalfont\tiny\sffamily #2}}}{#1}}}
\newcommand{\comment}[1]{}
\DeclarePairedDelimiter\abs{\lvert}{\rvert}
\DeclarePairedDelimiter\brackets{(}{)}

\title{\vspace{-2.0cm}Aufgabe 2: Dreiecksbeziehungen}
\author{Teilnahme ID: 48313\\Nikolas Kilian}
\date{\today}

\usepackage{Csharp}
\usepackage{lastpage}
\usepackage{fancyhdr}
\pagestyle{fancy} 

\makeatletter
\let\runauthor\@author
\makeatother
\lhead{\runauthor}
\fancyhead[R]{Aufgabe 2: Dreiecksbeziehungen\\\leftmark}
\cfoot{\thepage\ / \pageref{LastPage}}

\begin{document}
\maketitle
\tableofcontents

\section{Lösungsidee}
Mein Lösungsansatz ist ein Greedy-Algorithmus, wobei ich schrittweise Dreiecke an eine Liste von Dreiecken anhänge. Jeder Schritt probiert alle noch nicht hinzugefügten Dreiecke in allen ihrer Versionen (Rotation \& Spiegelung) anzuhängen, und hängt immer das Dreieck was dabei am wenigsten horizontalen Platz benötigt an.

\section{Umsetzung}
\textit{Aufgrund von Zeitproblemen ist meine Umsetzung nicht vollständig}
Um das Arbeiten mit Dreiecken leichter zu machen, wandele ich zuerst die Dreiecke in ihre Seitenlängen und Winkel um.
Die Umsetzung meiner Lösungsidee ist größtenteils trivial, bis auf das Anhängen von Dreiecken.
Zum Anhängen von Dreiecken ermittle ich zuerst die geringste x-Position für die das Dreieck flachliegend rechts angehängt werden kann, daraufhin probiere ich das Dreieck soweit wie möglich nach rechts drehen, indem ich mit immer kleineren Schritten diesen Winkel approximiere.

\section{Beispiele}
\newcommand{\Ex}[2]{
\frame{\includegraphics[scale=#1]{#2}}
}

\subsection{Beispiel 1}
\begin{center}
\Ex{0.98}{Ex1}
\end{center}

\subsection{Beispiel 2}
\begin{center}
\Ex{0.75}{Ex2}
\end{center}

\subsection{Beispiel 3}
\begin{center}
\Ex{0.65}{Ex3}
\end{center}

\subsection{Beispiel 4}
\begin{center}
\Ex{0.6}{Ex4}
\end{center}

\subsection{Beispiel 5}
\begin{center}
\Ex{0.45}{Ex5}
\end{center}

\section{Code}
\begin{Csharp}[caption=class Results]
output.Text = $@"Länge: {TriangleArranger.SortedLength(triangles).ToString("0.####")}
Dreiecke: 
{string.Join("\n", triangles.Select(x => $"{order[x]}: ({x.a.x.ToString("0.####")}, {x.a.y.ToString("0.####")}), ({x.b.x.ToString("0.####")}, {x.b.y.ToString("0.####")}), ({x.c.x.ToString("0.####")}, {x.c.y.ToString("0.####")})"))}";
\end{Csharp}

\begin{Csharp}[caption=class Triangle]
public double[] angles, lengths;

public TriangleArchetype(Triangle triangle)
{
    lengths = new[]
    {
        triangle.a.Distance(triangle.b),
        triangle.b.Distance(triangle.c),
        triangle.c.Distance(triangle.a),
    };

    angles = new[]
    {
        MathHelper.SmallerAngleSide(triangle.a.Angle(triangle.b) - triangle.a.Angle(triangle.c)),
        MathHelper.SmallerAngleSide(triangle.b.Angle(triangle.a) - triangle.a.Angle(triangle.c)),
        MathHelper.SmallerAngleSide(triangle.c.Angle(triangle.a) - triangle.a.Angle(triangle.b)),
    };
}

public TriangleArchetype Turn(int amount) => this.Let(@this => new TriangleArchetype // Lambdas can't use this => pass it as an argument
{
    angles = Enumerable.Range(0, 3).Select(z => @this.angles[(z + amount) % 3]).ToArray(),
    lengths = Enumerable.Range(0, 3).Select(z => @this.lengths[(z + amount) % 3]).ToArray()
});
public TriangleArchetype Mirror() => this.Let(@this => new TriangleArchetype
{
    angles = Enumerable.Range(0, 3).Select(z => @this.angles[(3 - z) % 3]).ToArray(),
    lengths = Enumerable.Range(0, 3).Select(z => @this.lengths[(3 - z) % 3]).ToArray()
});
\end{Csharp}

\begin{Csharp}[caption=class Triangle]
public Vector a, b, c;
public Vector this[int index] => MathHelper.PositiveModulo(index, 0, 3).Let(x =>
        x == 0 ? a 
    : x == 1 ? b
    : x == 2 ? c
    : throw new InvalidOperationException());
    
public Triangle(TriangleArchetype archetype, Vector positionOffset, double angleOffset)
{
    a = positionOffset;
    b = a + new Vector(archetype.angles[0] + angleOffset) * archetype.lengths[0];
    c = a + new Vector(angleOffset) * archetype.lengths[2];
}

public bool Intersects(Triangle other)
{
    var edges = new[] { (a, b), (b, c), (c, a) };
    var otherEdges = new[] { (other.a, other.b), (other.b, other.c), (other.c, other.a) };
    return edges.Any(x => otherEdges.Any(y => Vector.IntersectingLines(x.Item1, x.Item2, y.Item1, y.Item2)));
}

public bool Surrounds(Vector other, double epsilon) =>
    (Vector.OrientationApprox(a, b, other, epsilon), Vector.OrientationApprox(b, c, other, epsilon), Vector.OrientationApprox(c, a, other, epsilon))
    .Let(x => x.Item1 == x.Item2 && x.Item2 == x.Item3 && x.Item1 != Vector.VectorOrder.Collinear);
\end{Csharp}

\begin{Csharp}[caption=static class TriangleArranger]
public static List<Triangle> ArrangeTriangles(in List<TriangleArchetype> triangleArchetypesIn, out Dictionary<Triangle, int> order)
{
    var orderOut = new Dictionary<Triangle, int>();
    var triangles = new List<Triangle>();

    Triangle last;
    triangles.Add(last = new Triangle(new Vector(-1, 0), new Vector(-1, 0), new Vector(0, 0)));

    List<TriangleArchetype> triangleArchetypes = new List<TriangleArchetype>(triangleArchetypesIn);

    int n = 0;
    while (triangleArchetypes.Any())
    {
        var (value, comparable) = triangleArchetypes
            .SelectMany(x => new[] { (x, x), (x, x.Mirror()), (x, x.Turn(1)), (x, x.Turn(1).Mirror()), (x, x.Turn(2)), (x, x.Turn(2).Mirror()) })
            .Select(x => (x.Item1, AddTriangle(x.Item2, new List<Triangle>(triangles))))
            .MinValue(x => Math.Max(x.Item2.a.x, Math.Max(x.Item2.b.x, x.Item2.c.x)) - Math.Min(x.Item2.a.x, Math.Min(x.Item2.b.x, x.Item2.c.x)));

        triangles.Add(last = value.Item2);
        triangleArchetypes.Remove(value.Item1);
        orderOut[value.Item2] = triangleArchetypesIn.IndexOf(value.Item1);
    }

    order = orderOut;
    return triangles.Skip(1).ToList();
}

public static double epsilon = 1E-10;

public static Triangle AddTriangle(TriangleArchetype toAdd, List<Triangle> triangles)
{
    Triangle added;

    Vector upper = new Vector(toAdd.angles[0]) * toAdd.lengths[0];
    double rise = upper.x / upper.y;

    double maxX = double.NegativeInfinity;

    foreach ((Vector start, Vector end) in triangles.SelectMany(x => new[] { (x.a, x.b), (x.b, x.c), (x.c, x.a) }))
    {
        if (start.y.Approx(end.y, epsilon)) maxX = Math.Max(maxX, Math.Max(start.x, end.x));
        else
        {
            double startX = start.x - rise * start.y;
            double endX = end.x - rise * end.y;
            double lambda = MathHelper.Clamp((upper.y - start.y) / (end.y - start.y), 0, 1);
            maxX = Math.Max(maxX, Math.Max(startX * (1 - lambda) + endX * lambda, end.y > start.y ? startX : endX));
        }
    }

    added = null; // Avoid unassigned compilation errors
                    // Use small steps to approximate max angle
    double lastSuccess = 0, lastFailure = Math.PI - toAdd.angles[0];
    for (double angleCurrent = lastFailure; Math.Abs(lastSuccess - lastFailure) > 1E-5; angleCurrent = (lastSuccess + lastFailure) / 2d)
    {
        added = new Triangle(toAdd, new Vector(maxX, 0), angleCurrent);
        // Check for intersections
        if (triangles.Any(x => x.Intersects(added)
        || x.Surrounds(added.a, epsilon) || x.Surrounds(added.b, epsilon) || x.Surrounds(added.c, epsilon)
        || added.Surrounds(x.a, epsilon) || added.Surrounds(x.b, epsilon) || added.Surrounds(x.c, epsilon)))
        {
            lastFailure = angleCurrent;
        }
        else
        {
            lastSuccess = angleCurrent;
        }
    }
    added = new Triangle(toAdd, new Vector(maxX, 0), lastSuccess);

    return added;
}
\end{Csharp}

\end{document}